#!/bin/busybox sh
#
# By Chih-Wei Huang <cwhuang@linux.org.tw>
# and Thorsten Glaser <tg@mirbsd.org>
#
# Last updated 2018/01/26
#
# License: GNU Public License
# We explicitely grant the right to use the scripts
# with Android-x86 project.
#

PATH=/sbin:/bin:/system/bin:/system/xbin; export PATH

# auto installation
[ -n "$AUTO_INSTALL" ] && INSTALL=1

# configure debugging output
if [ -n "$DEBUG" -o -n "$INSTALL" ]; then
	LOG=/tmp/log
	set -x
else
	LOG=/dev/null
	test -e "$LOG" || busybox mknod $LOG c 1 3
fi
exec 2>> $LOG

chmod 755 /sbin/mount.ntfs-3g
chmod 755 /sbin/grub
chmod 755 /sbin/mkntfs
chmod 755 /sbin/efibootmgr

# early boot
if test x"$HAS_CTTY" != x"Yes"; then
	# initialise /proc and /sys
	busybox mount -t proc proc /proc
	busybox mount -t sysfs sys /sys
	# let busybox install all applets as symlinks
	busybox --install -s
	# spawn shells on tty 2 and 3 if debug or installer
	if test -n "$DEBUG" || test -n "$INSTALL"; then
		# ensure they can open a controlling tty
		mknod /dev/tty c 5 0
		# create device nodes then spawn on them
		mknod /dev/tty2 c 4 2 && openvt
		mknod /dev/tty3 c 4 3 && openvt
	fi
	if test -z "$DEBUG" || test -n "$INSTALL"; then
		echo 0 0 0 0 > /proc/sys/kernel/printk
	fi
	# initialise /dev (first time)
	mkdir -p /dev/block
	echo /sbin/mdev > /proc/sys/kernel/hotplug
	mdev -s
	# re-run this script with a controlling tty
	exec env HAS_CTTY=Yes setsid cttyhack /bin/sh "$0" "$@"
fi

# now running under a controlling tty; debug output from stderr into log file
# boot up Android

error()
{
	echo $*
	return 1
}

try_mount()
{
	RW=$1; shift
	if [ "${ROOT#*:/}" != "$ROOT" ]; then
		# for NFS roots, use nolock to avoid dependency to portmapper
		mount -o $RW,noatime,nolock $@
		return $?
	fi
	case $(blkid $1) in
		*TYPE=*ntfs*)
			mount.ntfs-3g -o rw,force $@
			;;
		*TYPE=*)
			mount -o $RW,noatime $@
			;;
		*)
			return 1
			;;
	esac
}

extract_magisk_apk(){



mkdir -p "$TMPDIR/magisk32"
mkdir -p "$TMPDIR/magisk"
 

unzip -o "$APKFILE" "lib/x86_64/*" -d "$TMPDIR/magisk" &>/dev/null
chmod -R 777 "$TMPDIR/magisk"
unzip -o "$APKFILE" "lib/x86/*" -d "$TMPDIR/magisk32" &>/dev/null
chmod -R 777 "$TMPDIR/magisk32"

}


random_str(){
local FROM
local TO
FROM="$1"; TO="$2"
tr -dc A-Za-z0-9 </dev/urandom | head -c $(($FROM+$(($RANDOM%$(($TO-$FROM+1))))))
}


magisk_loader(){
    local item

    magisk_postfsdata=`random_str 6 15`
    magisk_service=`random_str 6 15`
    magisk_boot_complete=`random_str 6 15`
    dev_random=`random_str 7 10`

    # always use "/dev/<random_string>" as magisk tmpfs
    MAGISKTMP="/dev/$dev_random"
    echo -e "\nMAGISKTMP=/dev/$dev_random" >>/bin/utils.sh
    for item in post-fs-data.sh service.sh magisk.rc overlay.sh magisksu_survival.sh; do
         sed -i "s|\${{MAGISKTMP}}|$MAGISKTMP|g" /magisk/$item
    done
    sed -i "s|\${{POSTFSDATA}}|$magisk_postfsdata|g" /magisk/magisk.rc
    sed -i "s|\${{SERVICE}}|$magisk_service|g" /magisk/magisk.rc
    sed -i "s|\${{BOOTCOMPLETED}}|$magisk_boot_complete|g" /magisk/magisk.rc
}





check_root()
{
	if [ "`dirname $1`" = "/dev" ]; then
		[ -e $1 ] || return 1
		blk=`basename $1`
		[ ! -e /dev/block/$blk ] && ln $1 /dev/block
		dev=/dev/block/$blk
	else
		dev=$1
	fi
	try_mount ro $dev /mnt || return 1
	if [ -n "$iso" -a -e /mnt/$iso ]; then
		mount --move /mnt /iso
		mkdir /mnt/iso
		mount -o loop /iso/$iso /mnt/iso
	fi
  INITRD_REAL=initrd_real.img
  APKFILE=/mnt/$SRC/magisk.apk
  echo "$dev" >"$MAGISKCORE/config"
	if [ -e /mnt/$SRC/$INITRD_REAL ]; then
		zcat /mnt/$SRC/$INITRD_REAL | cpio -id > /dev/null
  elif [ -e /mnt/$SRC/initrd.img ]; then
    zcat /mnt/$SRC/initrd.img | cpio -id > /dev/null
	elif [ -b /dev/$INITRD_REAL ]; then
		zcat /dev/$INITRD_REAL | cpio -id > /dev/null
	else
		return 1
	fi
     if [ ! -f "/mnt/$SRC/boot-magisk.img" ]; then
         rm -rf  "/mnt/$SRC/boot-magisk.img"
         zcat "/boot.img.gz" >"/mnt/$SRC/boot-magisk.img"
     fi
}

remount_rw()
{
	# "foo" as mount source is given to workaround a Busybox bug with NFS
	# - as it's ignored anyways it shouldn't harm for other filesystems.
	mount -o remount,rw foo /mnt
}

warn_no_magisk(){
echo "WARNING: magisk.apk does not exist. Boot Android with no Magisk"
}


debug_shell()
{
	if [ -x system/bin/sh ]; then
		echo Running MirBSD Korn Shell...
		USER="($1)" system/bin/sh -l 2>&1
	else
		echo Running busybox ash...
		sh 2>&1
	fi
}

abort(){
echo "$1"
sleep 5
exit 1
}



init_magisk(){
# exit when detect itself

test -e /dev/.initrd-magisk && abort "WARING: Invalid initialization! Exit in 5 second..."

# point out that initrd-magisk is already used

rm -rf /dev/.initrd-magisk
echo -n >/dev/.initrd-magisk

clear

. /bin/utils.sh
. /bin/info.sh

echo_log "initrd-magisk Android x86 $initrd_magisk_ver"
echo -n Initialize Magisk environment...

[ -z "$SRC" -a -n "$BOOT_IMAGE" ] && SRC=`dirname $BOOT_IMAGE`

for c in `cat /proc/cmdline`; do
	case $c in
		iso-scan/filename=*)
			SRC=iso
			eval `echo $c | cut -b1-3,18-`
			;;
		*)
			;;
	esac
done


mkdir -p /first_stage
mkdir -p /overlay.d
mkdir -p /tmp
mount -t tmpfs tmpfs /first_stage
mount -t tmpfs ".magisk/block" /overlay.d
mount -t tmpfs tmpfs /tmp
cd /first_stage
while :; do
	for device in ${ROOT:-/dev/[hmnsvx][dmrv][0-9a-z]*}; do
		check_root $device && break 2
		mountpoint -q /mnt && umount /mnt
	done
	sleep 1
	echo -n .
done

# do not allow real initrd override files
rm -rf /first_stage/bin/utils.sh /first_stage/bin/magisk.sh /first_stage/bin/info.sh /first_stage/scripts/*magisk* /first_stage/magisk

echo ""

( # disable magisk with flag FIXFS

if [ "$FIXFS" == "1" ]; then
    echo_log "Disable all Magisk modules"
    mkdir /data
    mount_data_part /data
    for magisk_module in $(ls /data/adb/modules); do
        echo -n >/data/adb/modules/$magisk_module/disable && debug_log "initrd-magisk: disable $magisk_module"
    done
    umount -l /data
fi
)


MAGISKBASE=MAGISK_FILES_BASE
rm -rf /scripts/*magisk*

# BEGIN
    cp /bin/magisk.sh /scripts/99_magisk
    mkdir -p "$MAGISKCORE"
    cp "$APKFILE" "$MAGISKCORE/magisk.apk"
    APKFILE="$MAGISKCORE/magisk.apk"
    extract_magisk_apk
    magisk_loader
# END


# continue boot

cp -af /first_stage/* /
umount -l /first_stage
rm -rf /first_stage
chmod 777 /init; exec /init
}

init_magisk

